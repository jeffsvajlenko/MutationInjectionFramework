#include <config.h>
#ifdef HAVE_STDIO_H
#include <stdio.h>
#endif
#ifdef HAVE_STDARG_H
#include <stdarg.h>
#endif
#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif
#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif
#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif
#include "monitor.h"
#include "engine.h"
#include "md5.h"
#include "sha.h"
#include "base64.h"
#include "alert.h"
#include "process.h"
static X X (X * X);
static X *X (X *);
static X X (X * X);

X X (X *X) {
    return (X && *X);
}

X *X (X *X) {
    X *X;
    X (X);
    X = X (X, 0);
    return (X ? ++X : X);
}

X X (X *X, X X) {
    X *X = X;
    X X;
    X (X);
    for (X = 0; X < X; X++, X++) {
        if ((*X == 0) || (*X == 0)) {
            *X = 0;
            return;
        }
    }
    X[X - 0] = 0;
}

X *X (X *X) {
    X (X);
    X (X);
    X (X);
    return X;
}

X *X (X *X) {
    X *X = X;
    X (X);
    while (*X == 0 || *X == 0 || *X == 0 || *X == 0)
        X++;
    return X (X, X);
}

X *X (X *X) {
    X *X = X;
    X (X);
    while (*X)
        X++;
    while (*--X == 0 || *X == 0 || *X == 0 || *X == 0)
        *X = 0;
    return X;
}

X X (X *X) {
    X *X = X;
    X X = 0;
    X (X);
    if (*X == 0 || *X == 0) {
        X = *X;
        X++;
    }
    else {
        return;
    }
    while (*X != X && *X != 0) {
        *(X - 0) = *X;
        X++;
    }
    *(X - 0) = 0;
    return;
}

X *X (X *X, X X, X X) {
    X *X = X;
    while (X && *X) {
        if (*X == X)
            *X = X;
        X++;
    }
    return (X);
}

X *X (X **X, const X *X, const X *X) {
    X X;
    X X;
    X (X && * X && X && X);
    X = X (*X, X);
    X = X (X) - X (X);
    if (X == 0)
        return *X;
    if (X > 0)
        X *= X;
    else
        X = 0;
    {
        X *X, *X;
        X X = X (X);
        X *X = X (X (*X) + X + 0);
        X = *X;
        *X = 0;
        while ((X = X (X, X))) {
            *X = 0;
            X (X, X);
            X (X, X);
            X += X;
            X = X;
        }
        X (X, X);
        X (*X);
        *X = X;
    }
    return *X;
}

X X (X *X, const X *X) {
    X X = 0;
    X *X = X;
    X (X && X);
    while ((X = X (X, X))) {
        X++;
        X++;
    }
    return X;
}

X X (const X *X, const X *X) {
    if ((!X || !X) || *X != *X)
        return X;
    while (*X && *X) {
        if (X (*X++) != X (*X++))
            return X;
    }
    return X;
}

X X (X *X) {
    X X;
    X X;
    X (X);
    for (X = X = 0; *(X + X) != 0; X++, X++) {
        if (*(X + X) == 0) {
            switch (*(X + X + 0)) {
            case 0 :
                *(X + X) = 0;
                X++;
                break;
            case 0 :
                *(X + X) = 0;
                X++;
                break;
            case 0 :
                *(X + X) = 0;
                X++;
                break;
            case 0 :
                *(X + X) = 0;
                X++;
                break;
            case 0 :
                *(X + X) = 0;
                X++;
                break;
            default :
                *(X + X) = *(X + X);
            }
        }
        else {
            *(X + X) = *(X + X);
        }
    }
    *(X + X) = 0;
}

X X (const X *X) {
    X X;
    X (X);
    for (X = X; X; X = X->X) {
        if (X (X->X, X)) {
            return X;
        }
    }
    return X;
}

X X (const X *X) {
    X X;
    X (X);
    for (X = X; X; X = X->X)
        if (X (X->X, X))
            return X;
    return X;
}

X X () {
    X X = 0;
    X X;
    for (X = X; X; X = X->X)
        X += 0;
    return X;
}

X X () {
    X (0);
    X (0, 0, X (X.X));
    X (0, 0, X (X.X));
    X (0, 0, X (X.X));
    X (0, 0, X.X ? 0 : 0);
    X (0, 0, X.X ? 0 : 0);
    X (0, 0, X.X ? 0 : 0);
    X (0, 0, X.X ? 0 : 0);
    X (0, 0, X.X ? 0 : 0);
    X (0, 0, X.X);
    X (0, 0);
    if (X.X) {
        X X = X.X;
        for (X = X.X; X; X = X->X)
            X (0, X->X, X->X ? 0 : 0);
        X (0);
    }
    else {
        X (0);
    }
    X (0, 0, X (X.X.X));
    X (0, 0, X (X.X.X));
    X (0, 0, X.X.X ? X.X.X : 0, X.X.X ? 0 : 0);
    X (0, 0, X.X ? 0 : 0);
    if (X.X) {
        X (0, 0, X.X ? X.X : 0);
        X (0, 0, X.X);
        X (0, 0, X.X ? 0 : 0);
        X (0, 0, X.X ? 0 : 0);
        if (X.X) {
            X (0, 0, X.X);
            if (X.X != X) {
                X (0, 0, X.X);
            }
            else {
                X (0, 0, 0);
            }
            X (0, 0, X.X ? 0 : 0);
        }
        X (0, 0, (X.X != X) && X () ? 0 : (X.X != X) ? 0 : X () ? 0 : 0);
    }
    {
        X X;
        for (X = X.X; X; X = X->X) {
            X (0, 0, X (X -> X));
            X (0, 0);
            if (X->X == (~((X) 0))) {
                X (0);
            }
            else {
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
                if (X (X->X, X))
                    X (0);
            }
            X (0);
        }
    }
    X (0);
}

X X (X X) {
    X X;
    X X;
    X X;
    X X;
    X X;
    X X;
    X X;
    X X;
    X (X);
    X (0, X [X -> X], X -> X);
    X (0, 0, X (X -> X));
    if (X->X == X)
        X (0, 0, X->X);
    else if (X->X != X)
        X (0, 0, X->X);
    X (0, 0, X [X -> X]);
    if (X->X) {
        X X = 0;
        X (0, 0);
        while (X->X->X[X])
            X (0, X->X->X[X++]);
        X (0);
    }
    if (X->X) {
        X X = 0;
        X (0, 0);
        while (X->X->X[X])
            X (0, X->X->X[X++]);
        X (0);
    }
    for (X = X->X; X; X = X->X)
        if (X->X != X)
            X (0, 0, X->X);
    if (X->X) {
        switch (X->X->X) {
        case X :
            X (0, 0, X->X->X, X[X->X->X]);
            break;
        case X :
            X (0, 0, X->X->X, X[X->X->X]);
            break;
        default :
            X (0, 0, X->X->X, X[X->X->X]);
            break;
        }
    }
    if (X->X)
        X (0, 0, X->X->X, X[X->X->X]);
    if (X->X)
        X (0, 0, (X) X->X->X, X[X->X->X]);
    if (X->X)
        X (0, 0, (X) X->X->X, X[X->X->X]);
    if (X->X) {
        for (X = X->X; X; X = X->X) {
            if (X->X == X) {
                if (X->X.X) {
                    X (0, 0, X -> X, X -> X, X -> X ? X -> X : 0, X -> X -> X, X -> X);
                    if (X->X.X != X)
                        X (0, 0, X->X.X);
                }
                else {
                    X (0, 0, X -> X, X -> X, X -> X ? X -> X : 0, X -> X -> X, X -> X);
                }
            }
            else if (X->X == X) {
                X (0, 0, X -> X, X -> X -> X, X -> X);
            }
        }
    }
    if (X->X)
        for (X = X->X; X; X = X->X)
            X (0, 0, X[X->X], X->X, X[X->X]);
    for (X = X->X; X; X = X->X) {
        if (X->X) {
            X (0, 0, X [X -> X]);
        }
        else {
            X (0, 0, X [X -> X], X -> X, X [X -> X]);
        }
    }
    for (X = X->X; X; X = X->X) {
        if (X->X) {
            X (0, 0, X [X -> X]);
        }
        else {
            X (0, 0, X [X -> X], X -> X, X [X -> X]);
        }
    }
    for (X = X->X; X; X = X->X) {
        if (X->X == X) {
            X (0, 0, X [X -> X], (X -> X > - 0) ? X -> X : X -> X, (X -> X > - 0) ? 0 : 0, X [X -> X]);
        }
        else if (X->X == X) {
            X (0, 0, X [X -> X], (X -> X > - 0) ? X -> X : X -> X, (X -> X > - 0) ? 0 : 0, X [X -> X]);
        }
    }
    for (X = X->X; X; X = X->X) {
        switch (X->X) {
        case X :
            X (0, 0, X[X->X], X->X / 0, X->X, X[X->X]);
            break;
        case X :
            X (0, 0, X[X->X], X->X / 0, X->X, X[X->X]);
            break;
        case X :
            X (0, 0, X[X->X], X->X, X->X, X[X->X]);
            break;
        case X :
            X (0, 0, X[X->X], X->X / 0, X->X, X[X->X]);
            break;
        case X :
            X (0, 0, X[X->X], X->X / 0, X->X, X[X->X]);
            break;
        case X :
            X (0, 0, X[X->X], X->X / 0, X->X, X[X->X]);
            break;
        }
    }
    if (X->X)
        X (0, 0, X->X);
    if (X->X)
        X (0, 0, X->X, X->X);
    for (X = X->X; X; X = X->X) {
        X (0, 0, X (X -> X));
        X (0, 0);
        if (X->X == (~((X) 0))) {
            X (0);
        }
        else {
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
            if (X (X->X, X))
                X (0);
        }
        X (0);
    }
    X (0);
}

X X () {
    X X;
    X X [X];
    X (0);
    for (X = X; X; X = X->X) {
        X (X);
    }
    X (X, 0, X);
    X (0, X);
}

X X (X *X) {
    X *X = X;
    X X = -0;
    X (X);
    if (!X (X)) {
        return (X);
    }
    if (!X (X)) {
        X (0, X, X);
        return (X);
    }
    if ((X = X (X, 0)) == (X *) X) {
        X (0, X, X, X);
        return (X);
    }
    X (X, 0, & X);
    X (X);
    if (X == -0) {
        X (0, X, X);
        return (X);
    }
    return (X) X;
}

X X (X X) {
    X X;
    X (X);
    X = 0;
    if ((X = X (X->X)))
        if ((X (X) > -0) || (X == X))
            return X;
    X (X -> X, 0, sizeof * (X -> X));
    return X;
}

X *X (X *X) {
    X X [X];
    struct  X *X;
    X X = (X && *X > 0) ? *X : X (X);
    X = X (&X);
    if (X (X, X, 0, X) <= 0) {
        return X;
    }
    return X (X);
}

X *X (X *X, X *X) {
    X X;
    X (X);
    if ((X = X (X, X))) {
        X X = X (&X);
        X X = X - X;
        return X (X, X);
    }
    return X (0);
}

X *X (X X, X *X) {
    static X X = 0;
    static X X = 0;
    static X X = 0;
    X X;
    X X;
    X X;
    X X [X];
    X *X = X;
    *X = 0;
    if ((X = X / X) > 0) {
        X += X (X, X -(X - X), 0, X, X);
        X -= X * X;
    }
    if ((X = X / X) > 0 || (X > 0)) {
        X += X (X, X -(X - X), 0, X, X);
        X -= X * X;
    }
    X = X / X;
    X += X (X, X -(X - X), 0, X, X);
    X -= X * X;
    return X (X);
}

X *X (X *X, X X) {
    X X = 0;
    X (X);
    switch (X) {
    case X :
        X = 0;
        break;
    case X :
        X = 0;
        break;
    default :
        return X;
    }
    if (X (X)) {
        X *X = X (X, 0);
        if (X) {
            X X;
            X X [X];
            X X [X];
            X *X = X;
            X X = 0;
            *X = 0;
            switch (X) {
            case X :
                X = X (X, X);
                break;
            case X :
                X = X (X, X);
                break;
            }
            if (X) {
                X (X);
                return X;
            }
            X (X);
            for (X = 0; X < X; ++X)
                X += X (X, X -(X - X), 0, X[X]);
            return (X (X));
        }
    }
    return X;
}

X X (X *X, X *X, X X) {
    X *X;
    X (X);
    X (X);
    X = X (X, X);
    if (X) {
        X X;
        switch (X) {
        case X :
            X = (!X (X, X, 0));
            break;
        case X :
            X = (!X (X, X, 0));
            break;
        default :
            X = X;
        }
        X (X);
        return (X);
    }
    return X;
}

X *X (X *X) {
    register X X, X;
    X *X;
    static X X [] = 0;
    X (X);
    X = (X *) X (0 * X (X) + 0);
    for (X = 0, X = 0; X[X]; X++, X++) {
        if (X ((X *) &X[X])) {
            X[X++] = 0;
            X[X++] = X[(X) X[X] >> 0];
            X[X] = X[(X) X[X] & 0];
        }
        else
            X[X] = (X) X[X];
    }
    X[X] = 0;
    return ((X *) X);
}

X *X (X *X) {
    register X X, X;
    if (!(X && *X))
        return X;
    X (X, 0, 0);
    for (X = 0, X = 0; X[X]; ++X, ++X) {
        if ((X[X] = X[X]) == 0) {
            X[X] = X (&X[X + 0]);
            X += 0;
        }
    }
    X[X] = 0;
    return X;
}

X *X () {
    X X = X.X;
    if (X == X) {
        return X (0);
    }
    while (X != X) {
        if (X->X == X) {
            break;
        }
        X = X->X;
    }
    if (X != X) {
        X *X, *X;
        X X [X];
        X (X, X, 0, X -> X, X -> X);
        if (!(X = X (X (X), (X *) X))) {
            X (0);
            return X;
        }
        X = X (sizeof (X), X +0);
        X (X, X, 0, X);
        X (X);
        return X;
    }
    X (0);
    return X;
}

X *X (const X *X, X X, X *X) {
    X X;
    X X = X;
    X *X = X (X);
    X (X);
    while (X) {
        X = X (X, X, X, X);
        if (X > -0 && X < X)
            break;
        if (X > -0)
            X = X + 0;
        else
            X *= 0;
        X = X (X, X);
    }
    *X = X;
    return X;
}

X X () {
    X X;
    for (X = 0; X < 0; X++)
        if (X (X) == -0 || X (0, X) != X)
            X (0, X, X);
}

X X () {
    X X;
#ifdef HAVE_UNISTD_H
    X X = X ();
#else
    X X = 0;
#endif
    for (X = 0; X < X; X++)
        (X) X (X);
    X = 0;
}

X X (X *X) {
    X X = X.X;
    while (X != X) {
        if (X (X->X, X) == 0) {
            return X;
        }
        X = X->X;
    }
    return X;
}

X X (X *X, X *X) {
    X X = X (X);
    X X [X];
    if (X == X) {
        return X;
    }
    switch (X->X) {
    case X :
        {
            X (X, X, X);
            break;
        }
    case X :
        {
            X X [X];
            X X [X];
            X *X;
            X (X, X -> X, X);
            X = X (X +0, 0) + 0;
            *X = 0;
            X (X, X -> X + X (X), X);
            X = X (X, 0);
            *X = 0;
            if (X (X, X, X, X, X) == X) {
                X (0);
                return X;
            }
            break;
        }
    case X :
        {
            X X [0];
            X *X;
            X (X, 0, 0, X -> X [0], X -> X [0]);
            X = X (X, X);
            X (X, X, X);
            break;
        }
    default :
        X (0);
        return X;
    }
    if (X (X, X->X) == 0) {
        return X;
    }
    return X;
}

static X *X (X *X) {
    return (X (X) ? X : 0);
}

static X X (X *X) {
    X X;
    static X X [] = 0;
    X (X);
    if (0 > *X || *X > 0)
        return X;
    if (*X == 0) {
        if (X (*(X + 0)) && X (*(X + 0)))
            return X;
        return X;
    }
    for (X = 0; X[X]; X++)
        if (*X == X[X])
            return X;
    return X;
}

static X X (X *X) {
    register X X;
    X = ((X[0] >= 0) ? ((X[0] & 0) - 0) + 0 : (X[0] - 0));
    X *= 0;
    X += (X[0] >= 0 ? ((X[0] & 0) - 0) + 0 : (X[0] - 0));
    return (X);
}


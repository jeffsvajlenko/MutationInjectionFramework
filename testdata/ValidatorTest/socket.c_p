#include "config.h"
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include "net.h"
#include "ssl.h"
#include "monitor.h"
#include "socket.h"
#define TYPE_LOCAL  0
#define TYPE_ACCEPT 1
struct Socket_T {
    int port;
    int type;
    int socket;
    char *host;
    Port_T Port;
    int timeout;
    int connection_type;
    ssl_connection *ssl;
    ssl_server_connection *sslserver;
};

Socket_T socket_new (const char *host, int port, int type, int use_ssl) {
    return socket_create_t (host, port, type, use_ssl, NET_TIMEOUT);
}

Socket_T socket_create (void *port) {
    int s;
    Socket_T S;
    Port_T p = port;
    ASSERT (port);
    if ((s = create_generic_socket (p)) != -1) {
        NEW (S);
        S->socket = s;
        S->type = p->type;
        S->port = p->port;
        S->timeout = p->timeout;
        S->connection_type = TYPE_LOCAL;
        if (p->family == AF_UNIX) {
            S->host = xstrdup (LOCALHOST);
        }
        else {
            S->host = xstrdup (p->hostname);
        }
        if (p->SSL.use_ssl) {
            if (!(S->ssl = new_ssl_connection (NULL, p->SSL.version))) {
                goto ssl_error;
            }
            if (!embed_ssl_socket (S->ssl, S->socket)) {
                goto ssl_error;
            }
            if (p->SSL.certmd5) {
                if (!check_ssl_md5sum (S->ssl, p->SSL.certmd5)) {
                    goto ssl_error;
                }
            }
        }
        S->Port = port;
        return S;
    ssl_error :
        socket_free (&S);
        return NULL;
    }
    return NULL;
}

Socket_T socket_create_t (const char *host, int port, int type, int use_ssl, int timeout) {
    int s;
    Socket_T S;
    int proto = type == SOCKET_UDP ? SOCK_DGRAM : SOCK_STREAM;
    ASSERT (host);
    ASSERT ((type == SOCKET_UDP) || (type == SOCKET_TCP));
    if (use_ssl) {
        ASSERT (type == SOCKET_TCP);
    }
    ASSERT (timeout > 0);
    if ((s = create_socket (host, port, proto, timeout)) != -1) {
        NEW (S);
        S->socket = s;
        S->port = port;
        S->type = proto;
        S->timeout = timeout;
        S->host = xstrdup (host);
        S->connection_type = TYPE_LOCAL;
        if (use_ssl) {
            if (!(S->ssl = new_ssl_connection (NULL, SSL_VERSION_AUTO))) {
                goto ssl_error;
            }
            if (!embed_ssl_socket (S->ssl, S->socket)) {
                goto ssl_error;
            }
        }
        return S;
    ssl_error :
        socket_free (&S);
        return NULL;
    }
    return NULL;
}

Socket_T socket_create_a (int socket, const char *remote_host, int port, void *sslserver) {
    Socket_T S;
    ASSERT (socket >= 0);
    ASSERT (remote_host);
    NEW (S);
    S->port = port;
    S->socket = socket;
    S->type = SOCK_STREAM;
    S->timeout = NET_TIMEOUT;
    S->host = xstrdup (remote_host);
    S->connection_type = TYPE_ACCEPT;
    if (sslserver) {
        S->sslserver = sslserver;
        if (!(S->ssl = insert_accepted_ssl_socket (S->sslserver))) {
            goto ssl_error;
        }
        if (!embed_accepted_ssl_socket (S->ssl, S->socket)) {
            goto ssl_error;
        }
    }
    return S;
ssl_error :
    socket_free (&S);
    return NULL;
}

void socket_free (Socket_T *S) {
    ASSERT (S && * S);
#ifdef HAVE_OPENSSL
    if ((*S)->ssl && (*S)->ssl->handler) {
        if ((*S)->connection_type == TYPE_LOCAL) {
            close_ssl_socket ((* S) -> ssl);
            delete_ssl_socket ((* S) -> ssl);
        }
        else if ((*S)->connection_type == TYPE_ACCEPT && (*S)->sslserver) {
            close_accepted_ssl_socket ((* S) -> sslserver, (* S) -> ssl);
        }
    }
#endif
    close_socket ((* S) -> socket);
    FREE ((* S) -> host);
    FREE (*S);
    (*S) = NULL;
}

int socket_is_ready (Socket_T S) {
    ASSERT (S);
    switch (S->type) {
    case SOCK_STREAM :
        return check_socket (S->socket);
    case SOCK_DGRAM :
        return check_udp_socket (S->socket);
    default :
        break;
    }
    return FALSE;
}

int socket_get_socket (Socket_T S) {
    ASSERT (S);
    return S->socket;
}

void *socket_get_Port (Socket_T S) {
    ASSERT (S);
    return S->Port;
}

int socket_get_remote_port (Socket_T S) {
    ASSERT (S);
    return S->port;
}

const char *socket_get_remote_host (Socket_T S) {
    ASSERT (S);
    return S->host;
}

int socket_print (Socket_T S, const char *m, ... ) {
    int n;
    long l;
    va_list ap;
    char *buf = NULL;
    ASSERT (S);
    ASSERT (m);
    va_start (ap, m);
    buf = format (m, ap, &l);
    va_end (ap);
    n = socket_write (S, buf, l);
    FREE (buf);
    return n;
}

int socket_write (Socket_T S, void *b, int size) {
    int n = 0;
    void *p = b;
    ASSERT (S);
    while (size > 0) {
        if (S->ssl) {
            n = send_ssl_socket (S->ssl, p, size);
        }
        else {
            n = sock_write (S->socket, p, size);
        }
        if (n <= 0)
            break;
        p += n;
        size -= n;
    }
    if (n < 0) {
        return -1;
    }
    return (int) p - (int) b;
}

int socket_read (Socket_T S, void *b, int size) {
    int n = 0;
    void *p = b;
    int timeout = 0;
    ASSERT (S);
    timeout = S->timeout;
    while (size > 0) {
        if (S->ssl) {
            n = recv_ssl_socket (S->ssl, p, size, timeout);
        }
        else {
            n = sock_read (S->socket, p, size, timeout);
        }
        if (n <= 0)
            break;
        p += n;
        size -= n;
        timeout = 0;
    }
    if (n < 0 && p == b) {
        return -1;
    }
    return (int) p - (int) b;
}

char *socket_readln (Socket_T S, char *s, int size) {
    char *p = s;
    ASSERT (S);
    while (--size && ((socket_read (S, s, 1)) > 0)) {
        if (*s++ == 10)
            break;
    }
    *s = 0;
    if (*p)
        return p;
    return NULL;
}

